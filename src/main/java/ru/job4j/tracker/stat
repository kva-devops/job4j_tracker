Для нагрузки создал новое действие, которое создает новые заявки (не размещая их в базе).
for (int j = 0; j < 100; j++) {
            for (int i = 0; i < count; i++) {
                String name = "name" + i;
                new Item(name);
                for (int k = 0; k < 1000; k++) {
                    SingleTracker.getInstance().init();
                    new Item(name);
                }
            }
        }

Запускаем программу > Выбраем пункт "Переполнить память" > Запускаем утилиты для профилирования
Анализ производил двумя утилитами: jconsole и jstat.
jconsole позволяет производить более наглядную оценку текущей нагрузки на память,
а в jstat в свою очередь более удобно работать с числовой информацией, особенно если заранее узнать
расшифровку столбцов.
При переполнении памяти происходит выход из приложения. По статистике видно, что случается это, когда
Old и Young Gen запоняется на примерно 97-99%. По графикам видно, что GC работает волнообразно.